"""
This type stub file was generated by pyright.
"""

import contextlib
import libcamera
import numpy as np
from collections.abc import Callable
from enum import Enum
from typing import Any, Literal, Optional, TypeVar, TypedDict, Union, overload, Generator, Self
from numpy.typing import NDArray
from PIL import Image
from picamera2.encoders import Encoder as Encoder
from picamera2.previews import DrmPreview as DrmPreview, NullPreview as NullPreview, QtGlPreview as QtGlPreview, QtPreview as QtPreview
from .configuration import CameraConfiguration as CameraConfiguration
from .job import Job as Job
from .request import CompletedRequest as CompletedRequest

"""picamera2 main class"""
STILL = ...
RAW = ...
VIDEO = ...
VIEWFINDER = ...
T = TypeVar("T")
_log = ...
class Preview(Enum):
    """Enum that applications can pass to the start_preview method."""
    NULL = NullPreview
    DRM = DrmPreview
    QT = QtPreview
    QTGL = QtGlPreview


class GlobalCameraInfo(TypedDict):
    """
    TypedDict for camera information fields.

    Fields:
        Model: The model name of the camera, as advertised by the camera driver.
        Location: A number reporting how the camera is mounted, as reported by libcamera.
        Rotation: How the camera is rotated for normal operation, as reported by libcamera.
        Id: An identifier string for the camera, indicating how the camera is connected.
        Num: A camera index.
    """
    Model: str
    Location: int
    Rotation: int
    Id: str
    Num: int
    ...


class CameraManager:
    def __init__(self) -> None:
        ...
    
    def setup(self) -> None:
        ...
    
    @property
    def cms(self) -> libcamera.CameraManager:
        ...
    
    def reset(self) -> None:
        ...
    
    def add(self, index, camera) -> None:
        ...
    
    def cleanup(self, index) -> None:
        ...
    
    def listen(self) -> None:
        ...
    
    def handle_request(self, flushid=...) -> None:
        """Handle requests

        :param cameras: Dictionary of Picamera2
        :type cameras: dict
        """
        ...
    


class Picamera2:
    """Welcome to the PiCamera2 class."""
    platform = ...
    _cm = ...
    @property
    def DEBUG(self) -> Literal[10]:
        """Now Deprecated

        Use:
        > import logging
        > logging.DEBUG
        """
        ...
    
    @property
    def INFO(self) -> Literal[20]:
        """Now Deprecated

        Use:
        > import logging
        > logging.INFO
        """
        ...
    
    @property
    def WARNING(self) -> Literal[30]:
        """Now Deprecated

        Use:
        > import logging
        > logging.WARNING
        """
        ...
    
    @property
    def ERROR(self) -> Literal[40]:
        """Now Deprecated

        Use:
        > import logging
        > logging.ERROR
        """
        ...
    
    @property
    def CRITICAL(self) -> Literal[50]:
        """Now Deprecated

        Use:
        > import logging
        > logging.CRITICAL
        """
        ...
    
    @staticmethod
    def set_logging(level=..., output=..., msg=...) -> None:
        """Configure logging for simple standalone use cases.

        For example:
        Picamera2.set_logging(Picamera2.INFO)
        Picamera2.set_logging(level=Picamera2.DEBUG, msg="%(levelname)s: %(message)s")

        :param level: A logging level
        :type level: int
        :param output: An output stream for the messages
        :type output: file-like object
        :param msg: Logging message format
        :type msg: str
        """
        ...
    
    @staticmethod
    def load_tuning_file(tuning_file, dir=...) -> dict[str, Any]:
        """Load the named tuning file.

        If dir is given, then only that directory is checked,
        otherwise a list of likely installation directories is searched

        :param tuning_file: Tuning file
        :type tuning_file: str
        :param dir: Directory of tuning file, defaults to None
        :type dir: str, optional
        :raises RuntimeError: Produced if tuning file not found
        :return: Dictionary of tuning file
        :rtype: dict
        """
        ...
    
    @staticmethod
    def find_tuning_algo(tuning, name) -> dict[str, dict]:
        """
        Return the parameters for the named algorithm in the given camera tuning.

        :param tuning: The camera tuning object
        :type tuning: dict
        :param name: The name of the algorithm
        :type name: str
        :rtype: dict
        """
        ...
    
    @staticmethod
    def global_camera_info() -> list[GlobalCameraInfo]:
        """
        Return Id string and Model name for all attached cameras, one dict per camera.

        Ordered correctly by camera number. Also return the location and rotation
        of the camera when known, as these may help distinguish which is which.
        """
        ...
    
    def __init__(self, camera_num=..., verbose_console=..., tuning=..., allocator=...) -> None:
        """Initialise camera system and open the camera for use.

        :param camera_num: Camera index, defaults to 0
        :type camera_num: int, optional
        :param verbose_console: Unused
        :type verbose_console: int, optional
        :param tuning: Tuning filename, defaults to None
        :type tuning: str, optional
        :raises RuntimeError: Init didn't complete
        """
        ...
    
    @property
    def camera_manager(self) -> libcamera.CameraManager:
        ...
    
    @property
    def preview_configuration(self) -> CameraConfiguration:
        ...
    
    @preview_configuration.setter
    def preview_configuration(self, value) -> None:
        ...
    
    @property
    def still_configuration(self) -> CameraConfiguration:
        ...
    
    @still_configuration.setter
    def still_configuration(self, value) -> None:
        ...
    
    @property
    def video_configuration(self) -> CameraConfiguration:
        ...
    
    @video_configuration.setter
    def video_configuration(self, value) -> None:
        ...
    
    @property
    def request_callback(self) -> None:
        """Now Deprecated"""
        ...
    
    @request_callback.setter
    def request_callback(self, value) -> None:
        """Now Deprecated"""
        ...
    
    @property
    def camera_properties(self) -> dict[str, Any]:
        """Camera properties

        :return: Camera properties
        :rtype: dict
        """
        ...
    
    @property
    def camera_controls(self) -> dict[str, tuple[Any, Any, Any]]:
        ...
    
    @property
    def title_fields(self) -> list[str]:
        """The metadata fields reported in the title bar of any preview window."""
        ...
    
    @title_fields.setter
    def title_fields(self, fields) -> None:
        ...
    
    def __enter__(self) -> Self:
        """Used for allowing use with context manager

        :return: self
        :rtype: Picamera2
        """
        ...
    
    def __exit__(self, exc_type, exc_val, exc_traceback) -> None:
        """Used for allowing use with context manager

        :param exc_type: Exception type
        :type exc_type: Type[BaseException]
        :param exc_val: Exception
        :type exc_val: BaseException
        :param exc_traceback: Traceback
        :type exc_traceback: TracebackType
        """
        ...
    
    def __del__(self) -> None:
        """Without this libcamera will complain if we shut down without closing the camera."""
        ...
    
    @property
    def sensor_modes(self) -> list[dict[str, Any]]:
        """The available sensor modes

        When called for the first time this will reconfigure the camera
        in order to read the modes.
        """
        ...
    
    def attach_preview(self, preview) -> None:
        ...
    
    def start_preview(self, preview=..., **kwargs) -> None:
        """
        Start the given preview which drives the camera processing.

        The preview may be either:
          None or False - in which case a NullPreview is made,
          True - which we hope in future to use to autodetect
          a Preview enum value - in which case a preview of that type is made,
          or an actual preview object.

        When using the enum form, extra keyword arguments can be supplied that
        will be forwarded to the preview class constructor.
        """
        ...
    
    def detach_preview(self) -> None:
        ...
    
    def stop_preview(self) -> None:
        """Stop preview

        :raises RuntimeError: Unable to stop preview
        """
        ...
    
    def close(self) -> None:
        """Close camera

        :raises RuntimeError: Closing failed
        """
        ...
    
    _raw_stream_ignore_list = ...
    def create_preview_configuration(self, main=..., lores=..., raw=..., transform=..., colour_space=..., buffer_count=..., controls=..., display=..., encode=..., queue=..., sensor=..., use_case=...) -> dict[str, Any]:
        """Make a configuration suitable for camera preview."""
        ...
    
    def create_still_configuration(self, main=..., lores=..., raw=..., transform=..., colour_space=..., buffer_count=..., controls=..., display=..., encode=..., queue=..., sensor=..., use_case=...) -> dict[str, Any]:
        """Make a configuration suitable for still image capture. Default to 2 buffers, as the Gl preview would need them."""
        ...
    
    def create_video_configuration(self, main=..., lores=..., raw=..., transform=..., colour_space=..., buffer_count=..., controls=..., display=..., encode=..., queue=..., sensor=..., use_case=...) -> dict[str, Any]:
        """Make a configuration suitable for video recording."""
        ...
    
    def check_stream_config(self, stream_config, name) -> None:
        """Check the configuration of the passed in config.

        Raises RuntimeError if the configuration is invalid.
        """
        ...
    
    def check_camera_config(self, camera_config) -> None:
        ...
    
    @staticmethod
    def align_stream(stream_config, optimal=...) -> None:
        ...
    
    @staticmethod
    def align_configuration(config, optimal=...) -> None:
        ...
    
    def configure_(self, camera_config) -> None:
        """Configure the camera system with the given configuration.

        :param camera_config: Camera configuration to be set
        :type camera_config: str, dict or CameraConfiguration
        :raises RuntimeError: Failed to configure at runtime
        :raises TypeError: Invalid type for `camera_config` given
        """
        ...
    
    def configure(self, camera_config=...) -> None:
        """Configure the camera system with the given configuration. Defaults to the 'preview' configuration."""
        ...
    
    def camera_configuration(self) -> dict[str, Any]:
        """Return the camera configuration."""
        ...
    
    def stream_configuration(self, name=...) -> dict[str, Any]:
        """Return the stream configuration for the named stream."""
        ...
    
    def start_(self) -> None:
        """Start the camera system running."""
        ...
    
    def start(self, config=..., show_preview=...) -> None:
        """
        Start the camera system running.

        Camera controls may be sent to the camera before it starts running.

        The following parameters may be supplied:

        config - if not None this is used to configure the camera. This is just a
            convenience so that you don't have to call configure explicitly.

        show_preview - whether to show a preview window. You can pass in the preview
            type or True to attempt to autodetect. If left as False you'll get no
            visible preview window but the "NULL preview" will still be run. The
            value None would mean no event loop runs at all and you would have to
            implement your own.
        """
        ...
    
    def cancel_all_and_flush(self) -> None:
        """
        Clear the camera system queue of pending jobs and cancel them.

        Depending on what was happening at the time, this may leave the camera system in
        an indeterminate state. This function is really only intended for tidying up
        after an operation has unexpectedly timed out (for example, the camera cable has
        become dislodged) so that the camera can be closed.
        """
        ...
    
    def stop_(self, request=...) -> tuple[Literal[True], None]:
        """Stop the camera.

        Only call this function directly from within the camera event
        loop, such as in a Qt application.
        """
        ...
    
    def stop(self) -> None:
        """Stop the camera."""
        ...
    
    def set_controls(self, controls) -> None:
        """Set camera controls. These will be delivered with the next request that gets submitted."""
        ...
    
    def process_requests(self, display) -> None:
        ...
    
    def wait(self, job: Job[T], timeout=...) -> T:
        """Wait for the given job to finish (if necessary) and return its final result.

        The job is obtained either by calling one of the Picamera2 methods asynchronously
        (passing wait=False), or as a parameter to the signal_function that can be
        supplied to those same methods.
        """
        ...
    
    def dispatch_functions(self, functions, wait, signal_function=..., immediate=...) -> Union[T, Job[T]]:
        """The main thread should use this to dispatch a number of operations for the event loop to perform.

        When there are multiple items each will be processed on a separate
        trip round the event loop, meaning that a single operation could stop and restart the
        camera and the next operation would receive a request from after the restart.

        The wait parameter should be one of:
            True - wait as long as necessary for the operation to compelte
            False - return immediately, giving the caller a "job" they can wait for
            None - default, if a signal_function was given do not wait, otherwise wait as long as necessary
            a number - wait for this number of seconds before raising a "timed out" error.
        """
        ...
    
    def set_frame_drops_(self, num_frames) -> tuple[Literal[True], None]:
        """Only for use within the camera event loop before calling drop_frames_."""
        ...
    
    def drop_frames_(self) -> tuple[Literal[True], None] | tuple[Literal[False], None]:
        ...
    
    def wait_for_timestamp_(self, timestamp_ns) -> tuple[Literal[True], None] | tuple[Literal[False], None]:
        ...
    
    @overload
    def drop_frames(self, num_frames, wait: None = ..., signal_function: None = ...) -> None:
        ...
    
    @overload
    def drop_frames(self, num_frames, wait: None = ..., signal_function: Callable[[Job], None] = ...) -> Job[None]:
        ...
    
    @overload
    def drop_frames(self, num_frames, wait: Literal[True] = ..., signal_function: Optional[Callable[[Job], None]] = ...) -> None:
        ...
    
    @overload
    def drop_frames(self, num_frames, wait: Literal[False] = ..., signal_function: Optional[Callable[[Job], None]] = ...) -> Job[None]:
        ...
    
    def drop_frames(self, num_frames, wait=..., signal_function=...) -> Union[None, Job[None]]:
        """Drop num_frames frames from the camera."""
        ...
    
    def capture_file_(self, file_output, name, format=..., exif_data=...) -> tuple[Literal[False], None] | tuple[Literal[True], Any]:
        ...
    
    @overload
    def capture_file(self, file_output, name=..., format=..., wait: None = ..., signal_function: None = ..., exif_data=...) -> dict[str, Any]:
        ...
    
    @overload
    def capture_file(self, file_output, name=..., format=..., wait: None = ..., signal_function: Callable[[Job], None] = ..., exif_data=...) -> Job[dict[str, Any]]:
        ...
    
    @overload
    def capture_file(self, file_output, name=..., format=..., wait: Literal[True] = ..., signal_function: Optional[Callable[[Job], None]] = ..., exif_data=...) -> dict[str, Any]:
        ...
    
    @overload
    def capture_file(self, file_output, name=..., format=..., wait: Literal[False] = ..., signal_function: Optional[Callable[[Job], None]] = ..., exif_data=...) -> Job[dict[str, Any]]:
        ...
    
    def capture_file(self, file_output, name=..., format=..., wait=..., signal_function=..., exif_data=...) -> Union[dict[str, Any], Job[dict[str, Any]]]:
        """Capture an image to a file in the current camera mode.

        Return the metadata for the frame captured.

        exif_data - dictionary containing user defined exif data (based on `piexif`). This will
            overwrite existing exif information generated by picamera2.
        """
        ...
    
    def switch_mode_(self, camera_config) -> tuple[Literal[True], dict[Any, Any]]:
        ...
    
    @overload
    def switch_mode(self, camera_config, wait: None = ..., signal_function: None = ...) -> dict[str, Any]:
        ...
    
    @overload
    def switch_mode(self, camera_config, wait: None = ..., signal_function: Callable[[Job], None] = ...) -> Job[dict[str, Any]]:
        ...
    
    @overload
    def switch_mode(self, camera_config, wait: Literal[True] = ..., signal_function: Optional[Callable[[Job], None]] = ...) -> dict[str, Any]:
        ...
    
    @overload
    def switch_mode(self, camera_config, wait: Literal[False] = ..., signal_function: Optional[Callable[[Job], None]] = ...) -> Job[dict[str, Any]]:
        ...
    
    def switch_mode(self, camera_config, wait=..., signal_function=...) -> Union[dict[str, Any], Job[dict[str, Any]]]:
        """Switch the camera into another mode given by the camera_config."""
        ...
    
    @overload
    def switch_mode_and_drop_frames(self, camera_config, num_frames, wait: None = ..., signal_function: None = ...) -> None:
        ...
    
    @overload
    def switch_mode_and_drop_frames(self, camera_config, num_frames, wait: None = ..., signal_function: Callable[[Job], None] = ...) -> Job[None]:
        ...
    
    @overload
    def switch_mode_and_drop_frames(self, camera_config, num_frames, wait: Literal[True] = ..., signal_function: Optional[Callable[[Job], None]] = ...) -> None:
        ...
    
    @overload
    def switch_mode_and_drop_frames(self, camera_config, num_frames, wait: Literal[False] = ..., signal_function: Optional[Callable[[Job], None]] = ...) -> Job[None]:
        ...
    
    def switch_mode_and_drop_frames(self, camera_config, num_frames, wait=..., signal_function=...) -> Union[None, Job[None]]:
        """Switch the camera into the mode given by camera_config and drop the first num_frames frames."""
        ...
    
    @overload
    def switch_mode_and_capture_file(self, camera_config, file_output, name=..., format=..., wait: None = ..., signal_function: None = ..., exif_data=..., delay=...) -> dict[str, Any]:
        ...
    
    @overload
    def switch_mode_and_capture_file(self, camera_config, file_output, name=..., format=..., wait: None = ..., signal_function: Callable[[Job], None] = ..., exif_data=..., delay=...) -> Job[dict[str, Any]]:
        ...
    
    @overload
    def switch_mode_and_capture_file(self, camera_config, file_output, name=..., format=..., wait: Literal[True] = ..., signal_function: Optional[Callable[[Job], None]] = ..., exif_data=..., delay=...) -> dict[str, Any]:
        ...
    
    @overload
    def switch_mode_and_capture_file(self, camera_config, file_output, name=..., format=..., wait: Literal[False] = ..., signal_function: Optional[Callable[[Job], None]] = ..., exif_data=..., delay=...) -> Job[dict[str, Any]]:
        ...
    
    def switch_mode_and_capture_file(self, camera_config, file_output, name=..., format=..., wait=..., signal_function=..., exif_data=..., delay=...) -> Union[dict[str, Any], Job[dict[str, Any]]]:
        """Switch the camera into a new (capture) mode, capture an image to file.

        Then return back to the initial camera mode.

        exif_data - dictionary containing user defined exif data (based on `piexif`). This will
            overwrite existing exif information generated by picamera2.
        """
        ...
    
    @overload
    def switch_mode_and_capture_request(self, camera_config, wait: None = ..., signal_function: None = ..., delay=...) -> CompletedRequest:
        ...
    
    @overload
    def switch_mode_and_capture_request(self, camera_config, wait: None = ..., signal_function: Callable[[Job], None] = ..., delay=...) -> Job[CompletedRequest]:
        ...
    
    @overload
    def switch_mode_and_capture_request(self, camera_config, wait: Literal[True] = ..., signal_function: Optional[Callable[[Job], None]] = ..., delay=...) -> CompletedRequest:
        ...
    
    @overload
    def switch_mode_and_capture_request(self, camera_config, wait: Literal[False] = ..., signal_function: Optional[Callable[[Job], None]] = ..., delay=...) -> Job[CompletedRequest]:
        ...
    
    def switch_mode_and_capture_request(self, camera_config, wait=..., signal_function=..., delay=...) -> Union[CompletedRequest, Job[CompletedRequest]]:
        """Switch the camera into a new (capture) mode and capture a request, then switch back.

        Applications should use this with care because it may increase the risk of CMA heap
        fragmentation. It may be preferable to use switch_mode_capture_request_and_stop and to
        release the request before restarting the original camera mode.
        """
        ...
    
    def capture_request_(self) -> tuple[Literal[False], None] | tuple[Literal[True], Any]:
        ...
    
    @overload
    def capture_request(self, wait: None = ..., signal_function: None = ..., flush=...) -> CompletedRequest:
        ...
    
    @overload
    def capture_request(self, wait: None = ..., signal_function: Callable[[Job], None] = ..., flush=...) -> Job[CompletedRequest]:
        ...
    
    @overload
    def capture_request(self, wait: Literal[True] = ..., signal_function: Optional[Callable[[Job], None]] = ..., flush=...) -> CompletedRequest:
        ...
    
    @overload
    def capture_request(self, wait: Literal[False] = ..., signal_function: Optional[Callable[[Job], None]] = ..., flush=...) -> Job[CompletedRequest]:
        ...
    
    def capture_request(self, wait=..., signal_function=..., flush=...) -> Union[CompletedRequest, Job[CompletedRequest]]:
        """Fetch the next completed request from the camera system.

        You will be holding a reference to this request so you must release it again to return it
        to the camera system.
        """
        ...
    
    @overload
    def switch_mode_capture_request_and_stop(self, camera_config, wait: None = ..., signal_function: None = ...) -> CompletedRequest:
        ...
    
    @overload
    def switch_mode_capture_request_and_stop(self, camera_config, wait: None = ..., signal_function: Callable[[Job], None] = ...) -> Job[CompletedRequest]:
        ...
    
    @overload
    def switch_mode_capture_request_and_stop(self, camera_config, wait: Literal[True] = ..., signal_function: Optional[Callable[[Job], None]] = ...) -> CompletedRequest:
        ...
    
    @overload
    def switch_mode_capture_request_and_stop(self, camera_config, wait: Literal[False] = ..., signal_function: Optional[Callable[[Job], None]] = ...) -> Job[CompletedRequest]:
        ...
    
    def switch_mode_capture_request_and_stop(self, camera_config, wait=..., signal_function=...) -> Union[CompletedRequest, Job[CompletedRequest]]:
        """Switch the camera into a new (capture) mode, capture a request in the new mode and then stop the camera."""
        ...
    
    @overload
    def capture_sync_request(self, wait: None = ..., signal_function: None = ...) -> CompletedRequest:
        ...
    
    @overload
    def capture_sync_request(self, wait: None = ..., signal_function: Callable[[Job], None] = ...) -> Job[CompletedRequest]:
        ...
    
    @overload
    def capture_sync_request(self, wait: Literal[True] = ..., signal_function: Optional[Callable[[Job], None]] = ...) -> CompletedRequest:
        ...
    
    @overload
    def capture_sync_request(self, wait: Literal[False] = ..., signal_function: Optional[Callable[[Job], None]] = ...) -> Job[CompletedRequest]:
        ...
    
    def capture_sync_request(self, wait=..., signal_function=...) -> Union[CompletedRequest, Job[CompletedRequest]]:
        """Return the first request when the camera system has reached sychronisation point.

        This method can be used when this camera is the sychronisation server or client
        for the software sync algorithm.
        """
        ...
    
    @contextlib.contextmanager
    def captured_request(self, wait=..., flush=...) -> Generator[CompletedRequest, Any, None]:
        """Capture a completed request using the context manager which guarantees its release."""
        ...
    
    @contextlib.contextmanager
    def captured_sync_request(self, wait=...) -> Generator[CompletedRequest, Any, None]:
        """Capture the first synchronised request using the context manager which guarantees its release.

        Only for use when running with the software sync algorithm.
        """
        ...
    
    def capture_metadata_(self) -> tuple[Literal[False], None] | tuple[Literal[True], Any]:
        ...
    
    @overload
    def capture_metadata(self, wait: None = ..., signal_function: None = ...) -> dict[str, Any]:
        ...
    
    @overload
    def capture_metadata(self, wait: None = ..., signal_function: Callable[[Job], None] = ...) -> Job[dict[str, Any]]:
        ...
    
    @overload
    def capture_metadata(self, wait: Literal[True] = ..., signal_function: Optional[Callable[[Job], None]] = ...) -> dict[str, Any]:
        ...
    
    @overload
    def capture_metadata(self, wait: Literal[False] = ..., signal_function: Optional[Callable[[Job], None]] = ...) -> Job[dict[str, Any]]:
        ...
    
    def capture_metadata(self, wait=..., signal_function=...) -> Union[dict[str, Any], Job[dict[str, Any]]]:
        """Fetch the metadata from the next camera frame."""
        ...
    
    def capture_buffer_(self, name) -> tuple[Literal[False], None] | tuple[Literal[True], Any]:
        ...
    
    @overload
    def capture_buffer(self, name=..., wait: None = ..., signal_function: None = ...) -> NDArray[np.uint8]:
        ...
    
    @overload
    def capture_buffer(self, name=..., wait: None = ..., signal_function: Callable[[Job], None] = ...) -> Job[NDArray[np.uint8]]:
        ...
    
    @overload
    def capture_buffer(self, name=..., wait: Literal[True] = ..., signal_function: Optional[Callable[[Job], None]] = ...) -> NDArray[np.uint8]:
        ...
    
    @overload
    def capture_buffer(self, name=..., wait: Literal[False] = ..., signal_function: Optional[Callable[[Job], None]] = ...) -> Job[NDArray[np.uint8]]:
        ...
    
    def capture_buffer(self, name=..., wait=..., signal_function=...) -> Union[NDArray[np.uint8], Job[NDArray[np.uint8]]]:
        """Make a 1d numpy array from the next frame in the named stream."""
        ...
    
    def capture_buffers_and_metadata_(self, names) -> tuple[Literal[False], None] | tuple[Literal[True], tuple[list[Any], Any]]:
        ...
    
    @overload
    def capture_buffers(self, names=..., wait: None = ..., signal_function: None = ...) -> tuple[list[NDArray[np.uint8]], dict[str, Any]]:
        ...
    
    @overload
    def capture_buffers(self, names=..., wait: None = ..., signal_function: Callable[[Job], None] = ...) -> Job[tuple[list[NDArray[np.uint8]], dict[str, Any]]]:
        ...
    
    @overload
    def capture_buffers(self, names=..., wait: Literal[True] = ..., signal_function: Optional[Callable[[Job], None]] = ...) -> tuple[list[NDArray[np.uint8]], dict[str, Any]]:
        ...
    
    @overload
    def capture_buffers(self, names=..., wait: Literal[False] = ..., signal_function: Optional[Callable[[Job], None]] = ...) -> Job[tuple[list[NDArray[np.uint8]], dict[str, Any]]]:
        ...
    
    def capture_buffers(self, names=..., wait=..., signal_function=...) -> Union[tuple[list[NDArray[np.uint8]], dict[str, Any]], Job[tuple[list[NDArray[np.uint8]], dict[str, Any]]]]:
        """Make a 1d numpy array from the next frame for each of the named streams."""
        ...
    
    @overload
    def switch_mode_and_capture_buffer(self, camera_config, name=..., wait: None = ..., signal_function: None = ..., delay=...) -> NDArray[np.uint8]:
        ...
    
    @overload
    def switch_mode_and_capture_buffer(self, camera_config, name=..., wait: None = ..., signal_function: Callable[[Job], None] = ..., delay=...) -> Job[NDArray[np.uint8]]:
        ...
    
    @overload
    def switch_mode_and_capture_buffer(self, camera_config, name=..., wait: Literal[True] = ..., signal_function: Optional[Callable[[Job], None]] = ..., delay=...) -> NDArray[np.uint8]:
        ...
    
    @overload
    def switch_mode_and_capture_buffer(self, camera_config, name=..., wait: Literal[False] = ..., signal_function: Optional[Callable[[Job], None]] = ..., delay=...) -> Job[NDArray[np.uint8]]:
        ...
    
    def switch_mode_and_capture_buffer(self, camera_config, name=..., wait=..., signal_function=..., delay=...) -> Union[NDArray[np.uint8], Job[NDArray[np.uint8]]]:
        """Switch the camera into a new (capture) mode, capture the first buffer.

        Then return back to the initial camera mode.
        """
        ...
    
    @overload
    def switch_mode_and_capture_buffers(self, camera_config, names=..., wait: None = ..., signal_function: None = ..., delay=...) -> tuple[list[NDArray[np.uint8]], dict[str, Any]]:
        ...
    
    @overload
    def switch_mode_and_capture_buffers(self, camera_config, names=..., wait: None = ..., signal_function: Callable[[Job], None] = ..., delay=...) -> Job[tuple[list[NDArray[np.uint8]], dict[str, Any]]]:
        ...
    
    @overload
    def switch_mode_and_capture_buffers(self, camera_config, names=..., wait: Literal[True] = ..., signal_function: Optional[Callable[[Job], None]] = ..., delay=...) -> tuple[list[NDArray[np.uint8]], dict[str, Any]]:
        ...
    
    @overload
    def switch_mode_and_capture_buffers(self, camera_config, names=..., wait: Literal[False] = ..., signal_function: Optional[Callable[[Job], None]] = ..., delay=...) -> Job[tuple[list[NDArray[np.uint8]], dict[str, Any]]]:
        ...
    
    def switch_mode_and_capture_buffers(self, camera_config, names=..., wait=..., signal_function=..., delay=...) -> Union[tuple[list[NDArray[np.uint8]], dict[str, Any]], Job[tuple[list[NDArray[np.uint8]], dict[str, Any]]]]:
        """Switch the camera into a new (capture) mode, capture the first buffers.

        Then return back to the initial camera mode.
        """
        ...
    
    def capture_array_(self, name) -> tuple[Literal[False], None] | tuple[Literal[True], Any]:
        ...
    
    @overload
    def capture_array(self, name=..., wait: None = ..., signal_function: None = ...) -> NDArray[np.uint8]:
        ...
    
    @overload
    def capture_array(self, name=..., wait: None = ..., signal_function: Callable[[Job], None] = ...) -> Job[NDArray[np.uint8]]:
        ...
    
    @overload
    def capture_array(self, name=..., wait: Literal[True] = ..., signal_function: Optional[Callable[[Job], None]] = ...) -> NDArray[np.uint8]:
        ...
    
    @overload
    def capture_array(self, name=..., wait: Literal[False] = ..., signal_function: Optional[Callable[[Job], None]] = ...) -> Job[NDArray[np.uint8]]:
        ...
    
    def capture_array(self, name=..., wait=..., signal_function=...) -> Union[NDArray[np.uint8], Job[NDArray[np.uint8]]]:
        """Make a 2d image from the next frame in the named stream."""
        ...
    
    def capture_arrays_and_metadata_(self, names) -> tuple[Literal[False], None] | tuple[Literal[True], tuple[list[Any], Any]]:
        ...
    
    @overload
    def capture_arrays(self, names=..., wait: None = ..., signal_function: None = ...) -> tuple[list[NDArray[np.uint8]], dict[str, Any]]:
        ...
    
    @overload
    def capture_arrays(self, names=..., wait: None = ..., signal_function: Callable[[Job], None] = ...) -> Job[tuple[list[NDArray[np.uint8]], dict[str, Any]]]:
        ...
    
    @overload
    def capture_arrays(self, names=..., wait: Literal[True] = ..., signal_function: Optional[Callable[[Job], None]] = ...) -> tuple[list[NDArray[np.uint8]], dict[str, Any]]:
        ...
    
    @overload
    def capture_arrays(self, names=..., wait: Literal[False] = ..., signal_function: Optional[Callable[[Job], None]] = ...) -> Job[tuple[list[NDArray[np.uint8]], dict[str, Any]]]:
        ...
    
    def capture_arrays(self, names=..., wait=..., signal_function=...) -> Union[tuple[list[NDArray[np.uint8]], dict[str, Any]], Job[tuple[list[NDArray[np.uint8]], dict[str, Any]]]]:
        """Make 2d image arrays from the next frames in the named streams."""
        ...
    
    @overload
    def switch_mode_and_capture_array(self, camera_config, name=..., wait: None = ..., signal_function: None = ..., delay=...) -> NDArray[np.uint8]:
        ...
    
    @overload
    def switch_mode_and_capture_array(self, camera_config, name=..., wait: None = ..., signal_function: Callable[[Job], None] = ..., delay=...) -> Job[NDArray[np.uint8]]:
        ...
    
    @overload
    def switch_mode_and_capture_array(self, camera_config, name=..., wait: Literal[True] = ..., signal_function: Optional[Callable[[Job], None]] = ..., delay=...) -> NDArray[np.uint8]:
        ...
    
    @overload
    def switch_mode_and_capture_array(self, camera_config, name=..., wait: Literal[False] = ..., signal_function: Optional[Callable[[Job], None]] = ..., delay=...) -> Job[NDArray[np.uint8]]:
        ...
    
    def switch_mode_and_capture_array(self, camera_config, name=..., wait=..., signal_function=..., delay=...) -> Union[NDArray[np.uint8], Job[NDArray[np.uint8]]]:
        """Switch the camera into a new (capture) mode, capture the image array data.

        Then return back to the initial camera mode.
        """
        ...
    
    @overload
    def switch_mode_and_capture_arrays(self, camera_config, names=..., wait: None = ..., signal_function: None = ..., delay=...) -> tuple[list[NDArray[np.uint8]], dict[str, Any]]:
        ...
    
    @overload
    def switch_mode_and_capture_arrays(self, camera_config, names=..., wait: None = ..., signal_function: Callable[[Job], None] = ..., delay=...) -> Job[tuple[list[NDArray[np.uint8]], dict[str, Any]]]:
        ...
    
    @overload
    def switch_mode_and_capture_arrays(self, camera_config, names=..., wait: Literal[True] = ..., signal_function: Optional[Callable[[Job], None]] = ..., delay=...) -> tuple[list[NDArray[np.uint8]], dict[str, Any]]:
        ...
    
    @overload
    def switch_mode_and_capture_arrays(self, camera_config, names=..., wait: Literal[False] = ..., signal_function: Optional[Callable[[Job], None]] = ..., delay=...) -> Job[tuple[list[NDArray[np.uint8]], dict[str, Any]]]:
        ...
    
    def switch_mode_and_capture_arrays(self, camera_config, names=..., wait=..., signal_function=..., delay=...) -> Union[tuple[list[NDArray[np.uint8]], dict[str, Any]], Job[tuple[list[NDArray[np.uint8]], dict[str, Any]]]]:
        """Switch the camera into a new (capture) mode, capture the image arrays.

        Then return back to the initial camera mode.
        """
        ...
    
    def capture_image_(self, name) -> tuple[Literal[False], None] | tuple[Literal[True], Any]:
        """Capture image

        :param name: Stream name
        :type name: str
        """
        ...
    
    @overload
    def capture_image(self, name=..., wait: None = ..., signal_function: None = ...) -> Image.Image:
        ...
    
    @overload
    def capture_image(self, name=..., wait: None = ..., signal_function: Callable[[Job], None] = ...) -> Job[Image.Image]:
        ...
    
    @overload
    def capture_image(self, name=..., wait: Literal[True] = ..., signal_function: Optional[Callable[[Job], None]] = ...) -> Image.Image:
        ...
    
    @overload
    def capture_image(self, name=..., wait: Literal[False] = ..., signal_function: Optional[Callable[[Job], None]] = ...) -> Job[Image.Image]:
        ...
    
    def capture_image(self, name=..., wait=..., signal_function=...) -> Union[Image.Image, Job[Image.Image]]:
        """Make a PIL image from the next frame in the named stream.

        :param name: Stream name, defaults to "main"
        :type name: str, optional
        :param wait: Wait for the event loop to finish an operation and signal us, defaults to True
        :type wait: bool, optional
        :param signal_function: Callback, defaults to None
        :type signal_function: function, optional
        :return: PIL Image
        :rtype: Image.Image
        """
        ...
    
    @overload
    def switch_mode_and_capture_image(self, camera_config, name=..., wait: None = ..., signal_function: None = ..., delay=...) -> Image.Image:
        ...
    
    @overload
    def switch_mode_and_capture_image(self, camera_config, name=..., wait: None = ..., signal_function: Callable[[Job], None] = ..., delay=...) -> Job[Image.Image]:
        ...
    
    @overload
    def switch_mode_and_capture_image(self, camera_config, name=..., wait: Literal[True] = ..., signal_function: Optional[Callable[[Job], None]] = ..., delay=...) -> Image.Image:
        ...
    
    @overload
    def switch_mode_and_capture_image(self, camera_config, name=..., wait: Literal[False] = ..., signal_function: Optional[Callable[[Job], None]] = ..., delay=...) -> Job[Image.Image]:
        ...
    
    def switch_mode_and_capture_image(self, camera_config, name=..., wait=..., signal_function=..., delay=...) -> Union[Image.Image, Job[Image.Image]]:
        """Switch the camera into a new (capture) mode, capture the image.

        Then return back to the initial camera mode.
        """
        ...
    
    def start_encoder(self, encoder=..., output=..., pts=..., quality=..., name=...) -> None:
        """Start encoder

        :param encoder: Sets encoder or uses existing, defaults to None
        :type encoder: Encoder, optional
        :raises RuntimeError: No encoder set or no stream
        """
        ...
    
    def stop_encoder(self, encoders=...) -> None:
        """Stops the encoder"""
        ...
    
    @property
    def encoders(self) -> set[Encoder]:
        """Extract current Encoder objects

        :return: Set of encoders
        :rtype: set
        """
        ...
    
    @encoders.setter
    def encoders(self, value) -> None:
        """Set Encoder to be used

        :param value: Encoder to be set
        :type value: Encoder
        :raises RuntimeError: Fail to pass Encoder
        """
        ...
    
    def start_recording(self, encoder, output, pts=..., config=..., quality=..., name=...) -> None:
        """Start recording a video using the given encoder and to the given output.

        Output may be a string in which case the correspondingly named file is opened.

        :param encoder: Video encoder
        :type encoder: Encoder
        :param output: FileOutput object
        :type output: FileOutput
        """
        ...
    
    def stop_recording(self) -> None:
        """Stop recording a video. The encode and output are stopped and closed."""
        ...
    
    def set_overlay(self, overlay) -> None:
        """Display an overlay on the camera image.

        The overlay may be either None, in which case any overlay is removed,
        or a 4-channel ``ndarray``, the last of thechannels being taken as the alpha channel.

        :param overlay: Overlay or None
        :type overlay: ndarray
        :raises RuntimeError: Must pass a 4-channel image
        """
        ...
    
    def start_and_capture_files(self, name=..., initial_delay=..., preview_mode=..., capture_mode=..., num_files=..., delay=..., show_preview=..., exif_data=...) -> None:
        """This function makes capturing multiple images more convenient.

        Should only be used in command line line applications (not from a Qt application, for example).
        If will configure the camera as requested and start it, switching between preview and still modes
        for capture. It supports the following parameters (all optional):

        name - name of the files to which to save the images. If more than one image is to be
            captured then it should feature a format directive that will be replaced by a counter.

        initial_delay - any time delay (in seconds) before the first image is captured. The camera
            will run in preview mode during this period. The default time is 1s.

        preview_mode - the camera mode to use for the preview phase (defaulting to the
            Picamera2 object's preview_configuration field).

        capture_mode - the camera mode to use to capture the still images (defaulting to the
            Picamera2 object's still_configuration field).

        num_files - number of files to capture (default 1).

        delay - the time delay for every capture after the first (default 1s).

        show_preview - whether to show a preview window (default: yes). The preview window only
            displays an image by default during the preview phase, so if captures are back-to-back
            with delay zero, then there may be no images shown. This parameter only has any
            effect if a preview is not already running. If it is, it would have to be stopped first
            (with the stop_preview method).

        exif_data - dictionary containing user defined exif data (based on `piexif`). This will
            overwrite existing exif information generated by picamera2.
        """
        ...
    
    def start_and_capture_file(self, name=..., delay=..., preview_mode=..., capture_mode=..., show_preview=..., exif_data=...) -> None:
        """This function makes capturing a single image more convenient.

        Should only be used in command line line applications (not from a Qt application, for example).
        If will configure the camera as requested and start it, switching from the preview to the still
        mode for capture. It supports the following parameters (all optional):

        name - name of the file to which to save the images.

        delay - any time delay (in seconds) before the image is captured. The camera
            will run in preview mode during this period. The default time is 1s.

        preview_mode - the camera mode to use for the preview phase (defaulting to the
            Picamera2 object's preview_configuration field).

        capture_mode - the camera mode to use to capture the still images (defaulting to the
            Picamera2 object's still_configuration field).

        show_preview - whether to show a preview window (default: yes). The preview window only
            displays an image by default during the preview phase. This parameter only has any
            effect if a preview is not already running. If it is, it would have to be stopped first
            (with the stop_preview method).

        exif_data - dictionary containing user defined exif data (based on `piexif`). This will
            overwrite existing exif information generated by picamera2.
        """
        ...
    
    def start_and_record_video(self, output, encoder=..., config=..., quality=..., show_preview=..., duration=..., audio=...) -> None:
        """This function makes video recording more convenient.

        Should only be used in command line applications (not from a Qt application, for example).
        It will configure the camera if requested and start it. The following parameters are required:

        output - the name of an output file (or an output object). If the output is a string,
            the correct output object will be created for "mp4" or "ts" files. All other formats
            will simply be written as flat files.

        The following parameters are optional:

        encoder - the encoder object to use. If unspecified, the MJPEGEncoder will be selected for
            files ending in ".mjpg" or .mjpeg", otherwise the H264Enccoder will be used.

        config - the camera configuration to apply. The default behaviour (given by the value None)
            is not to overwrite any existing configuration, though the "video" configuration will be
            applied if the camera is unconfigured.

        quality - an indication of the video quality to use. This will be ignored if the encoder
            object was created with all its quality parameters (such as bitrate) filled in.

        show_preview - whether to show a preview window (default: no). This parameter only has an
            effect if a preview is not already running, in which case that preview would need
            stopping first (using stop_preview) for any change to take effect.

        duration - the duration of the video. The function will wait this amount of time before
            stopping the recording and returning. The default behaviour is to return immediately
            and to leave the recoding running (the application will have to stop it later, for
            example by calling stop_recording).

        audio - whether to record audio. This is only effective when recording to an "mp4" or "ts"
            file, and there is a microphone installed and working as the default input device
            through Pulseaudio.
        """
        ...
    
    @overload
    def autofocus_cycle(self, wait: None = ..., signal_function: None = ...) -> bool:
        ...
    
    @overload
    def autofocus_cycle(self, wait: None = ..., signal_function: Callable[[Job], None] = ...) -> Job[bool]:
        ...
    
    @overload
    def autofocus_cycle(self, wait: Literal[True] = ..., signal_function: Optional[Callable[[Job], None]] = ...) -> bool:
        ...
    
    @overload
    def autofocus_cycle(self, wait: Literal[False] = ..., signal_function: Optional[Callable[[Job], None]] = ...) -> Job[bool]:
        ...
    
    def autofocus_cycle(self, wait=..., signal_function=...) -> Union[bool, Job[bool]]:
        """Switch autofocus to auto mode and run an autofocus cycle.

        Return True if the autofocus cycle focuses successuly, otherwise False.
        """
        ...
    


